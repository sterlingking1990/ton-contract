#include "imports/stdlib.fc";

;;define amount to keep
const const:min_tons_for_storage = 10000000; ;;0.01 TON

(int, slice, slice) load_data() inline {
    var ds = get_data().begin_parse();
    return (ds~load_uint(32),ds~load_msg_addr(),ds~load_msg_addr());
}

() save_data(int updated_count, slice sender_addr, slice owner_addr) impure inline {
    set_data(begin_cell()
        .store_uint(updated_count,32)
        .store_slice(sender_addr)
        .store_slice(owner_addr)
        .end_cell());
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    slice cs = in_msg_full.begin_parse();

    int flags = cs~load_uint(4);

    slice sender_address = cs~load_msg_addr();

    var (counter_value, recent_sender, owner_addr) = load_data();

    ;;Ensure the in_msg_body has at least 32 bits before loading the operation code
    if (in_msg_body.slice_bits() >= 32) {
        int op = in_msg_body~load_uint(32);

        ;;Check if the operation code is 1
        if (op == 1) {
            ;;get the increment by from the in message body
            ;;counter_val is preset on contract data store while set up
            int increment_by = in_msg_body~load_uint(32);
            save_data(counter_value + increment_by, sender_address, owner_addr);
            return ();
        }

        if(op == 2){
            ;;deposit
            return();
        }

        if(op == 3){
            ;;withdraw
            
            throw_unless(103, equal_slice_bits(sender_address,owner_addr));
            ;;amt to withdraw
            int amount_to_withdraw = in_msg_body~load_coins();
            var [balance, _] = get_balance();
            ;;throw err if trying to withdraw almost same amt in balance
            throw_unless(104, balance >= amount_to_withdraw);

            int return_val_to_send = min(amount_to_withdraw, balance - const:min_tons_for_storage);

            ;;sending internal message
            int msg_mode = 1; ;;0- ordinary msg, 1- pay transfer fees seperately

            var msg = begin_cell()
                .store_uint(0x18,6) ;;empty source
                .store_slice(sender_address) ;; destination add, since fund is withdrawn by sender to his sender wallet addr
                .store_coins(return_val_to_send)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
            send_raw_message(msg.end_cell(), msg_mode);

            return();
        }

        throw(777);
    }
    throw(777);
}

(int,slice,slice) get_contract_storage_data() method_id {
    var (counter_value,recent_sender,owner_addr) = load_data();
    return (
        counter_value,
        recent_sender,
        owner_addr
    );
}

int wallet_balance() method_id {
    var [balance,_] = get_balance();
    return balance;
}


